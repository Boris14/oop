Да се имплементира прост Cellular Automaton. [Wikipedia](https://en.wikipedia.org/wiki/Cellular_automaton) [WolframAlpha](https://mathworld.wolfram.com/CellularAutomaton.html)

Това е система, която съдържа поле от елементи(най-просто едномерен масив) със стойности(най-просто true/false) и правила за промяната на тези елементи. За всяка една комбинация от стойностите на елемент и неговите ляв и десен съсед има уникално правило, кото показва каква ще бъде новата стойност на този елемент.

Пример:
Според rule 30 ако имаме елемент 1 и съседи вляво 0 и вдясно 1 новата стойност ще бъде 1. АКо обаче левият съсед е 1 и десният 0 тогава новата стойност е 0.

Да се направи имплементация на Cellular Automaton, като:
- имплементацият да стане в клас с метод run, който приема за аргументи цяло число за брой итерации(поколения), които да се изпълнят, и ламбда функция, която да се извика след приключването на изпълнението *Важно: стойностите на елементите се обновяват след като приключи пресмятането на новите стойности. В противен случай за следващия елемент в масива ще се ползва грешна стойност за неговия съсед.*
- класът да има атрибути за полето с елементи и правилата, които да прилага. Тези атрибути да се подават в конструктора
- цикълът за итериране през списъка от елементи да се реализира чрез stream. Цикълът за итериране през поколения може да се направи с нормален цикъл
*За първия елемент левият съсед е последният елемент. За последния елемент десният съсед е първият елемент.*
- да се изписва състоянието на полето в началото на изпълнение и след всяко пресмятане на поколение. Крайният резултат да се подаде на ламбда функцията

Очакван изход при ползване на rule 30:

| ляв съсед | елемент | десен съсед | нова стойност |
|-----------|---------|-------------|---------------|
| 1         | 1       | 1           | 0             |
| 1         | 1       | 0           | 0             |
| 1         | 0       | 1           | 0             |
| 1         | 0       | 0           | 1             |
| 0         | 1       | 1           | 1             |
| 0         | 1       | 0           | 1             |
| 0         | 0       | 1           | 1             |
| 0         | 0       | 0           | 0             |
```
Starting field: 1 1 0 0
Generation 1: 1 0 1 1
Generation 2: 0 0 1 0
Generation 3: 0 1 1 1
```
